# 5.5 Sequence Diagrams

Sequence diagrams illustrate object interactions arranged in time sequence, showing the order of messages exchanged between components to accomplish specific functionality. These diagrams emphasize the temporal ordering of operations and clearly delineate responsibilities across system components, making them particularly valuable for understanding complex multi-component interactions like payment processing and real-time synchronization.

## User Authentication Sequence

**[DIAGRAM PLACEHOLDER: Figure 5.13 - User Login Sequence Diagram]**  
*A UML sequence diagram showing login interaction with vertical lifelines for:*
- *Student (Actor - leftmost)*
- *Mobile App (Flutter UI)*
- *Authentication Controller (BLoC)*
- *Firebase Authentication Service*
- *Cloud Firestore Database*
- *Horizontal arrows showing message flow with labels:*
  1. *Student → Mobile App: enters email & password*
  2. *Mobile App → Auth Controller: login(email, password)*
  3. *Auth Controller → Firebase Auth: signInWithEmailAndPassword()*
  4. *Firebase Auth → Firebase Auth: validate credentials (self-call)*
  5. *Firebase Auth → Auth Controller: return UserCredential + JWT token*
  6. *Auth Controller → Firestore: getUserProfile(userId)*
  7. *Firestore → Auth Controller: return User document*
  8. *Auth Controller → Mobile App: LoginSuccess(user, token)*
  9. *Mobile App → Mobile App: persist session token (self-call)*
  10. *Mobile App → Student: navigate to Home screen*
- *Activation bars showing when objects are processing*
- *Return messages shown as dashed lines*

The login sequence demonstrates the coordinated interaction between UI, business logic, authentication service, and database. The authentication controller acts as a mediator, preventing direct coupling between UI and Firebase services. The JWT token returned by Firebase Authentication persists in secure local storage, enabling automatic re-authentication on subsequent app launches without requiring password re-entry.

## Order Placement and Payment Sequence

**[DIAGRAM PLACEHOLDER: Figure 5.14 - Order Placement Sequence Diagram]**  
*A comprehensive sequence diagram with lifelines for:*
- *Student (Actor)*
- *Mobile App*
- *Checkout Controller*
- *Cart Manager*
- *Firestore Database*
- *Cloud Functions*
- *M-Pesa Daraja API*
- *Message sequence:*
  1. *Student → Mobile App: taps "Checkout"*
  2. *Mobile App → Cart Manager: getCartItems()*
  3. *Cart Manager → Mobile App: return items array*
  4. *Mobile App → Student: display review screen*
  5. *Student → Mobile App: confirms order*
  6. *Mobile App → Checkout Controller: createOrder(items, total, preferences)*
  7. *Checkout Controller → Firestore: create Order document (status="Pending")*
  8. *Firestore → Checkout Controller: return Order ID*
  9. *Checkout Controller → Cloud Functions: initiatePayment(orderId, amount, phoneNumber)*
  10. *Cloud Functions → M-Pesa API: requestOAuthToken()*
  11. *M-Pesa API → Cloud Functions: return access token*
  12. *Cloud Functions → M-Pesa API: stkPush(amount, phone, callbackUrl)*
  13. *M-Pesa API → Cloud Functions: return request accepted*
  14. *Cloud Functions → Checkout Controller: return "Payment initiated"*
  15. *Checkout Controller → Mobile App: show "Waiting for payment..."*
  16. *Mobile App → Student: display spinner + instructions*
  17. *[Parallel] M-Pesa API → Student's Phone: STK Push prompt*
  18. *Student's Phone → M-Pesa API: M-Pesa PIN entry*
  19. *M-Pesa API → M-Pesa API: process payment (self-call)*
  20. *M-Pesa API → Cloud Functions: POST callback (payment result)*
  21. *Cloud Functions → Firestore: update Order (status="Paid", paymentRef)*
  22. *Firestore → Mobile App: snapshot listener triggers update*
  23. *Mobile App → Student: navigate to Order Tracking screen*
- *Alt frame showing payment failure path with error handling*

This sequence illustrates the most complex workflow in the system, involving five distinct components. The asynchronous nature of M-Pesa payment requires careful state management—the app cannot block waiting for payment completion since users might take several minutes to authorize. The Firestore snapshot listener pattern enables reactive UI updates: when Cloud Functions update the order's payment status, the listener fires automatically updating the app's UI without polling.

## Real-Time Order Tracking Sequence

**[DIAGRAM PLACEHOLDER: Figure 5.15 - Real-Time Order Tracking Sequence Diagram]**  
*Sequence diagram showing real-time synchronization:*
- *Lifelines: Student, Mobile App, Firestore Database, Cloud Messaging, Cafeteria Staff, Admin Dashboard*
- *Message sequence:*
  1. *Student → Mobile App: opens Order Tracking screen*
  2. *Mobile App → Firestore: attachSnapshotListener(orderRef)*
  3. *Firestore → Mobile App: initial order data (status="Preparing")*
  4. *Mobile App → Student: display "Order is being prepared"*
  5. *[Time passes...]*
  6. *Cafeteria Staff → Admin Dashboard: marks order "Ready"*
  7. *Admin Dashboard → Firestore: updateOrder(orderId, status="Ready")*
  8. *Firestore → Firestore: trigger onUpdate Cloud Function (self-call)*
  9. *Firestore → Cloud Messaging: sendNotification(userId, "Order ready!")*
  10. *Cloud Messaging → Student's Device: push notification*
  11. *Firestore → Mobile App: snapshot event (updated order data)*
  12. *Mobile App → Mobile App: rebuild UI with new status (self-call)*
  13. *Mobile App → Student: display "Ready for Pickup!" with animation*
- *Opt frame showing "if app is backgrounded" flow with notification handling*

The real-time tracking sequence showcases Firestore's live synchronization capabilities. The snapshot listener maintains an open WebSocket connection receiving instant updates when the order document changes. This eliminates the need for inefficient polling (repeatedly querying "has my order status changed?") reducing server load and battery consumption while providing superior user experience with instant updates.

## Menu Loading and Caching Sequence

**[DIAGRAM PLACEHOLDER: Figure 5.16 - Menu Loading with Cache Sequence Diagram]**  
*Sequence diagram demonstrating offline-first architecture:*
- *Lifelines: Student, Mobile App, Menu Controller, Local Cache (SQLite), Firestore Database*
- *Message sequence:*
  1. *Student → Mobile App: launches app*
  2. *Mobile App → Menu Controller: loadMenu()*
  3. *Menu Controller → Local Cache: getMenuItems()*
  4. *Local Cache → Menu Controller: return cached items (with timestamp)*
  5. *Menu Controller → Mobile App: display cached menu immediately*
  6. *Mobile App → Student: menu appears (instant, from cache)*
  7. *[Parallel] Menu Controller → Firestore: queryMenuItems(since=lastCacheTime)*
  8. *Firestore → Menu Controller: return updated items (if any)*
  9. *Alt frame: "if updates exist"*
     - *Menu Controller → Local Cache: updateCache(newItems)*
     - *Local Cache → Menu Controller: cache updated*
     - *Menu Controller → Mobile App: notify UI refresh*
     - *Mobile App → Student: menu updates with fade animation*
  10. *Alt frame: "if network unavailable"*
     - *Firestore → Menu Controller: connection error*
     - *Menu Controller → Mobile App: operate from cache only*
     - *Mobile App → Student: show "Offline mode" indicator*

This sequence demonstrates the offline-first pattern improving perceived performance and reliability. Users see menu content instantly from cache rather than waiting for network requests. The parallel network fetch updates the cache in background without blocking UI rendering. This pattern ensures the app remains functional even without connectivity—users can browse menus and prepare carts offline, with synchronization occurring when connectivity resumes.

## Loyalty Points Calculation Sequence

**[DIAGRAM PLACEHOLDER: Figure 5.17 - Loyalty Points Calculation Sequence Diagram]**  
*Sequence diagram for automated points calculation:*
- *Lifelines: Firestore Database, Cloud Functions (onOrderComplete trigger), Loyalty Engine, User Document*
- *Message sequence:*
  1. *Admin Dashboard → Firestore: updateOrder(orderId, status="Completed")*
  2. *Firestore → Cloud Functions: trigger onOrderComplete(orderSnapshot)*
  3. *Cloud Functions → Cloud Functions: extract userId, orderTotal (self-call)*
  4. *Cloud Functions → Loyalty Engine: calculatePoints(orderTotal)*
  5. *Loyalty Engine → Loyalty Engine: points = floor(total / 100) (self-call)*
  6. *Loyalty Engine → Loyalty Engine: checkPromotions() (self-call)*
  7. *Loyalty Engine → Loyalty Engine: applyMultiplier() if applicable (self-call)*
  8. *Loyalty Engine → Cloud Functions: return earnedPoints*
  9. *Cloud Functions → Firestore: getUser(userId)*
  10. *Firestore → Cloud Functions: return User document*
  11. *Cloud Functions → Cloud Functions: newBalance = currentBalance + earnedPoints (self-call)*
  12. *Cloud Functions → Firestore: updateUser(userId, {loyaltyPoints: newBalance})*
  13. *Cloud Functions → Firestore: createTransaction({type:"earned", points, source:orderId})*
  14. *Firestore → Mobile App: snapshot listener fires*
  15. *Mobile App → Student: show notification "You earned X points!"*

This sequence illustrates server-side business logic execution via Cloud Functions. The Firestore trigger automatically invokes the function when an order status changes to "Completed", ensuring points calculation occurs reliably without requiring client-side code execution. Server-side calculation prevents client manipulation—users cannot modify code to award themselves arbitrary points.

---

**Word Count**: ~680 words  
**Status**: ✅ Complete
