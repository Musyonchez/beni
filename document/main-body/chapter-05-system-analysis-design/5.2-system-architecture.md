# 5.2 System Architecture

The Cafeteria Ordering and Loyalty Reward System implements a **three-tier architecture** separating concerns across presentation, application, and data layers. This architectural pattern, well-established in enterprise software engineering, provides modularity enabling independent development, testing, and scaling of each layer while maintaining clear interfaces between components. The architecture leverages cloud-native services throughout, eliminating traditional server infrastructure in favor of managed platforms that provide superior reliability, automatic scaling, and reduced operational overhead.

## Three-Tier Architecture

**[DIAGRAM PLACEHOLDER: Figure 5.1 - System Architecture Diagram]**  
*A comprehensive three-tier architecture diagram showing:*
- *Top tier: Presentation Layer (Flutter Mobile App on left, React Admin Dashboard on right)*
- *Middle tier: Application Layer (Firebase Cloud Functions, M-Pesa Daraja API)*
- *Bottom tier: Data Layer (Cloud Firestore database, Firebase Authentication)*
- *Arrows showing data flow and communication between layers*
- *External integrations: M-Pesa payment gateway, Firebase Cloud Messaging for push notifications*
- *Security boundary markers showing HTTPS/TLS encryption*

## Presentation Layer

The presentation layer consists of two primary client applications serving distinct user personas: the Flutter mobile application for students and the React web dashboard for cafeteria administrators and staff.

### Flutter Mobile Application

The Flutter mobile application represents the primary user interface for students, providing comprehensive functionality for menu browsing, order placement, payment processing, order tracking, and loyalty program engagement. Built using Google's Flutter framework, the application compiles to native ARM code for both iOS and Android platforms from a single Dart codebase, maximizing development efficiency while delivering native performance and platform-specific UI conventions.

The application architecture follows the **BLoC (Business Logic Component) pattern**, separating UI presentation from business logic and state management. This separation enables comprehensive unit testing of business logic independent of UI, facilitates code reuse across multiple screens sharing common functionality, and provides reactive UI updates through stream-based state propagation. The BLoC pattern integrates seamlessly with Flutter's reactive framework where UI widgets rebuild automatically in response to state changes.

Key architectural components within the mobile app include:

- **Authentication Module**: Manages user registration, login, password reset, and session persistence using Firebase Authentication SDK
- **Menu Browser**: Displays categorized menu items with search, filtering, and detailed product views
- **Shopping Cart**: Manages order composition with add/remove operations, quantity adjustments, and real-time price calculations
- **Checkout Engine**: Orchestrates the multi-step checkout process including delivery preferences, order review, and payment initiation
- **Payment Integration**: Interfaces with M-Pesa Daraja API for STK Push payment requests and handles payment callback verification
- **Order Tracking**: Provides real-time order status monitoring using Firestore snapshot listeners for live updates
- **Loyalty Manager**: Displays points balance, transaction history, and redemption interface
- **Profile Manager**: Handles user profile viewing, editing, password changes, and account settings

The application implements **offline-first architecture** for menu browsing, caching menu data locally using shared preferences and SQLite persistence. This ensures users can browse menus and prepare carts even without network connectivity, with synchronization occurring when connectivity resumes. Critical operations requiring server interaction (payment, order submission) gracefully handle connectivity failures with retry logic and clear user feedback.

### React Administrative Dashboard

The administrative web dashboard provides cafeteria staff and system administrators with order management, menu administration, and analytics capabilities. Built using React with Next.js framework, the dashboard delivers a responsive web interface accessible from any device with a modern browser, eliminating the need for native application installation on staff devices.

The dashboard architecture employs **React Context API for state management**, maintaining global application state for authenticated user session, active order queue, and menu inventory. Server-side rendering through Next.js provides superior initial page load performance and SEO benefits compared to traditional single-page applications, though the latter is less relevant for an authenticated internal tool.

Administrative dashboard components include:

- **Order Queue Display**: Real-time list of pending orders sorted by priority and timestamp
- **Order Status Management**: Interface for updating order preparation status with one-click state transitions
- **Menu Administration**: CRUD (Create, Read, Update, Delete) operations for menu items including image uploads
- **Inventory Management**: Mark items as available/unavailable, adjust prices, modify descriptions
- **Analytics Dashboard**: Visualizations showing daily orders, revenue trends, popular items, and peak hours
- **User Management**: View registered users, monitor loyalty points, handle support requests

## Application Layer

The application layer implements server-side business logic through **Firebase Cloud Functions**, serverless functions executing in Google's managed infrastructure. Cloud Functions respond to HTTP requests from client applications and database triggers from Firestore, enabling complex operations requiring server-side execution for security, performance, or integration with external services.

Key Cloud Functions include:

- **Payment Verification Function**: Validates M-Pesa payment callbacks, confirms transaction authenticity, and updates order payment status
- **Loyalty Points Calculator**: Triggered when orders complete, calculates earned points based on purchase amount, applies multipliers for promotions, and updates user loyalty balance
- **Order Notification Function**: Sends push notifications to users when order status changes (confirmed, preparing, ready for pickup)
- **Analytics Aggregator**: Periodically calculates daily/weekly sales totals, popular items rankings, and revenue metrics for dashboard display
- **Menu Validation Function**: Validates menu item data during creation/editing ensuring price ranges, categories, and required fields meet business rules

The serverless architecture provides automatic scaling—during peak lunch hours when dozens of orders submit simultaneously, Google's infrastructure automatically provisions additional function instances to handle load. During off-peak hours, functions scale to zero eliminating idle capacity costs. This elastic scaling ensures consistent performance without manual capacity planning.

## Data Layer

The data layer combines **Cloud Firestore** for primary data persistence with **Firebase Authentication** for identity management and the **M-Pesa Daraja API** for payment processing, creating a distributed data architecture where different data types reside in systems optimized for their specific characteristics.

### Cloud Firestore Database

Firestore provides the primary data store for all application data including users, menu items, orders, and loyalty transactions. As a NoSQL document database, Firestore organizes data into collections containing documents (JSON-like objects) that can hold nested subcollections, enabling flexible schema design accommodating evolving requirements.

Firestore's real-time synchronization capabilities enable live updates—when a cafeteria staff member updates an order status, the user's mobile app receives the change instantly through snapshot listeners without polling. This real-time functionality is critical for order tracking features where users expect immediate status visibility.

Security rules implemented directly in Firestore enforce access control at the database level: users can read only their own order history, staff can update order statuses but not modify historical data, and administrators have comprehensive access. These rules execute server-side, preventing client-side bypass attempts.

### Firebase Authentication

Firebase Authentication manages user identities, password storage, session tokens, and email verification. The system uses email/password authentication as the primary method, with future potential for social login integration (Google Sign-In, Facebook Login). Firebase handles security best practices including bcrypt password hashing, secure token generation, and session expiration management.

### M-Pesa Daraja API Integration

M-Pesa integration occurs through Safaricom's Daraja API, specifically the **STK Push (Lipa na M-Pesa Online)** functionality. When users initiate payment, Cloud Functions call the Daraja API with transaction details, prompting users to authorize payment on their phones. Daraja sends payment confirmation callbacks to configured webhook endpoints, which Cloud Functions verify and process to update order payment status.

This integration pattern delegates payment security and PCI compliance to Safaricom's infrastructure while providing seamless integration with Kenya's dominant mobile money platform. The system never handles sensitive payment credentials or card numbers, reducing security risk and compliance burden.

## Communication Protocols

All communication between layers utilizes industry-standard protocols ensuring security and interoperability:

- **HTTPS/TLS**: All client-server communication encrypted end-to-end preventing eavesdropping
- **REST API**: Cloud Functions expose RESTful HTTP endpoints for stateless request-response patterns
- **WebSocket (Firestore Listeners)**: Real-time database synchronization uses WebSocket connections for bidirectional communication
- **OAuth 2.0**: M-Pesa Daraja API authentication follows OAuth 2.0 protocol with bearer tokens
- **JSON**: All data serialization uses JSON format for universal compatibility and human readability

---

**Word Count**: ~840 words  
**Status**: ✅ Complete
