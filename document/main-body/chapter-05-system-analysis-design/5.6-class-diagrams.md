# 5.6 Class Diagrams

Class diagrams represent the static structure of the system by modeling classes (object templates), their attributes (data), methods (behavior), and relationships (associations, dependencies, inheritance). While the system uses Firestore's document-based NoSQL database rather than traditional object-relational mapping, class diagrams remain valuable for modeling the application's domain objects, data transfer objects, and business logic components.

## Core Domain Model

**[DIAGRAM PLACEHOLDER: Figure 5.18 - Core Domain Classes Diagram]**  
*A UML class diagram showing the primary business domain classes:*

**User Class:**
```
┌─────────────────────────────────┐
│          User                    │
├─────────────────────────────────┤
│ - userId: String                │
│ - name: String                  │
│ - email: String                 │
│ - phoneNumber: String           │
│ - passwordHash: String          │
│ - loyaltyPoints: int            │
│ - profileImageUrl: String       │
│ - emailVerified: bool           │
│ - createdAt: DateTime           │
│ - lastLoginAt: DateTime         │
├─────────────────────────────────┤
│ + register(): Future<bool>      │
│ + login(email, password): Future│
│ + updateProfile(): Future<void> │
│ + resetPassword(): Future<void> │
│ + getLoyaltyBalance(): int      │
│ + getOrderHistory(): List<Order>│
└─────────────────────────────────┘
```

**MenuItem Class:**
```
┌─────────────────────────────────┐
│        MenuItem                  │
├─────────────────────────────────┤
│ - itemId: String                │
│ - name: String                  │
│ - description: String           │
│ - category: String              │
│ - price: double                 │
│ - imageUrl: String              │
│ - preparationTime: int          │
│ - isAvailable: bool             │
│ - nutritionalInfo: Map          │
│ - allergens: List<String>       │
│ - createdAt: DateTime           │
│ - updatedAt: DateTime           │
├─────────────────────────────────┤
│ + create(): Future<String>      │
│ + update(): Future<void>        │
│ + delete(): Future<void>        │
│ + toggleAvailability(): void    │
│ + applyDiscount(percent): double│
└─────────────────────────────────┘
```

**Order Class:**
```
┌─────────────────────────────────┐
│          Order                   │
├─────────────────────────────────┤
│ - orderId: String               │
│ - userId: String                │
│ - items: List<OrderItem>        │
│ - subtotal: double              │
│ - loyaltyDiscount: double       │
│ - total: double                 │
│ - status: OrderStatus           │
│ - paymentStatus: PaymentStatus  │
│ - deliveryPreferences: String   │
│ - specialInstructions: String   │
│ - estimatedPickupTime: DateTime │
│ - createdAt: DateTime           │
│ - completedAt: DateTime         │
├─────────────────────────────────┤
│ + create(): Future<String>      │
│ + updateStatus(status): Future  │
│ + calculateTotal(): double      │
│ + applyLoyaltyDiscount(points)  │
│ + cancel(): Future<void>        │
│ + complete(): Future<void>      │
└─────────────────────────────────┘
```

**OrderItem Class (Composition within Order):**
```
┌─────────────────────────────────┐
│        OrderItem                 │
├─────────────────────────────────┤
│ - itemId: String                │
│ - name: String                  │
│ - quantity: int                 │
│ - unitPrice: double             │
│ - subtotal: double              │
│ - specialInstructions: String   │
├─────────────────────────────────┤
│ + calculateSubtotal(): double   │
│ + updateQuantity(qty): void     │
└─────────────────────────────────┘
```

*Relationships shown:*
- *User "1" ──── "0..*" Order (one user has zero or many orders)*
- *Order "1" ◆──── "1..*" OrderItem (composition - order contains items)*
- *MenuItem "1" ──── "0..*" OrderItem (one menu item referenced in many order items)*
- *User "1" ──── "0..1" Cart (one user has zero or one active cart)*

## Payment and Transaction Classes

**[DIAGRAM PLACEHOLDER: Figure 5.19 - Payment Domain Classes Diagram]**  
*UML class diagram for payment-related classes:*

**Payment Class:**
```
┌─────────────────────────────────┐
│         Payment                  │
├─────────────────────────────────┤
│ - paymentId: String             │
│ - orderId: String               │
│ - userId: String                │
│ - amount: double                │
│ - paymentMethod: PaymentMethod  │
│ - mpesaTransactionId: String    │
│ - mpesaReceiptNumber: String    │
│ - phoneNumber: String           │
│ - status: PaymentStatus         │
│ - initiatedAt: DateTime         │
│ - completedAt: DateTime         │
│ - failureReason: String         │
├─────────────────────────────────┤
│ + initiate(): Future<bool>      │
│ + verify(): Future<bool>        │
│ + confirm(): void               │
│ + fail(reason): void            │
│ + refund(): Future<bool>        │
└─────────────────────────────────┘
```

**LoyaltyTransaction Class:**
```
┌─────────────────────────────────┐
│    LoyaltyTransaction            │
├─────────────────────────────────┤
│ - transactionId: String         │
│ - userId: String                │
│ - points: int                   │
│ - type: TransactionType         │
│ - sourceOrderId: String         │
│ - description: String           │
│ - balanceAfter: int             │
│ - createdAt: DateTime           │
│ - expiresAt: DateTime           │
├─────────────────────────────────┤
│ + create(): Future<String>      │
│ + getBalance(userId): int       │
│ + earnPoints(userId, points)    │
│ + redeemPoints(userId, points)  │
│ + getHistory(userId): List      │
└─────────────────────────────────┘
```

**Cart Class:**
```
┌─────────────────────────────────┐
│           Cart                   │
├─────────────────────────────────┤
│ - cartId: String                │
│ - userId: String                │
│ - items: List<CartItem>         │
│ - subtotal: double              │
│ - updatedAt: DateTime           │
├─────────────────────────────────┤
│ + addItem(item, qty): void      │
│ + removeItem(itemId): void      │
│ + updateQuantity(itemId, qty)   │
│ + clear(): void                 │
│ + calculateSubtotal(): double   │
│ + convertToOrder(): Order       │
└─────────────────────────────────┘
```

*Relationships:*
- *Payment "1" ──── "1" Order (one-to-one association)*
- *LoyaltyTransaction "0..*" ──── "1" User (many transactions per user)*
- *LoyaltyTransaction "0..1" ──── "0..1" Order (optional link to source order)*
- *Cart "1" ◆──── "0..*" CartItem (composition)*

## Controller and Service Classes

**[DIAGRAM PLACEHOLDER: Figure 5.20 - Application Logic Classes Diagram]**  
*UML class diagram showing BLoC controllers and services:*

**AuthenticationController (BLoC):**
```
┌─────────────────────────────────┐
│   AuthenticationController       │
├─────────────────────────────────┤
│ - authService: AuthService      │
│ - currentUser: User?            │
│ - authStateStream: Stream       │
├─────────────────────────────────┤
│ + login(email, pwd): Future     │
│ + register(userData): Future    │
│ + logout(): Future<void>        │
│ + resetPassword(email): Future  │
│ + getCurrentUser(): User?       │
│ + listenAuthState(): Stream     │
└─────────────────────────────────┘
```

**OrderController (BLoC):**
```
┌─────────────────────────────────┐
│      OrderController             │
├─────────────────────────────────┤
│ - orderService: OrderService    │
│ - activeOrders: List<Order>     │
│ - orderHistory: List<Order>     │
├─────────────────────────────────┤
│ + createOrder(items): Future    │
│ + getActiveOrders(): Stream     │
│ + getOrderHistory(): Future     │
│ + trackOrder(orderId): Stream   │
│ + cancelOrder(orderId): Future  │
└─────────────────────────────────┘
```

**PaymentService:**
```
┌─────────────────────────────────┐
│       PaymentService             │
├─────────────────────────────────┤
│ - httpClient: HttpClient        │
│ - apiBaseUrl: String            │
├─────────────────────────────────┤
│ + initiateSTKPush(amount, phone)│
│ + verifyPayment(transactionId)  │
│ + queryPaymentStatus(ref): Map  │
│ + handleCallback(data): void    │
└─────────────────────────────────┘
```

**FirestoreService:**
```
┌─────────────────────────────────┐
│      FirestoreService            │
├─────────────────────────────────┤
│ - firestore: Firestore          │
├─────────────────────────────────┤
│ + getDocument(path): Future     │
│ + queryCollection(path): Stream │
│ + createDocument(path, data)    │
│ + updateDocument(path, data)    │
│ + deleteDocument(path): Future  │
│ + batchWrite(operations): Future│
└─────────────────────────────────┘
```

*Relationships:*
- *AuthenticationController ──uses──> FirestoreService (dependency)*
- *OrderController ──uses──> FirestoreService*
- *OrderController ──uses──> PaymentService*
- *All controllers inherit from base BLoC class (generalization)*

## Enumeration Types

The system defines several enumeration types ensuring type safety and preventing invalid state values:

**OrderStatus Enumeration:**
```
<<enumeration>>
OrderStatus
─────────────
PENDING_PAYMENT
PAYMENT_CONFIRMED
PREPARING
READY_FOR_PICKUP
COMPLETED
CANCELLED
```

**PaymentStatus Enumeration:**
```
<<enumeration>>
PaymentStatus
─────────────
INITIATED
PENDING
COMPLETED
FAILED
REFUNDED
```

**PaymentMethod Enumeration:**
```
<<enumeration>>
PaymentMethod
─────────────
MPESA
CASH
CARD (future)
```

**TransactionType Enumeration:**
```
<<enumeration>>
TransactionType
─────────────
EARNED
REDEEMED
EXPIRED
ADJUSTED
```

**UserRole Enumeration:**
```
<<enumeration>>
UserRole
─────────────
CUSTOMER
STAFF
ADMINISTRATOR
```

These enumerations prevent errors like setting order status to arbitrary strings ("almost done", "cooking") ensuring consistent state representation throughout the system. Firestore stores these as strings but application code enforces enum constraints.

## Key Relationships and Patterns

The class structure implements several design patterns:

**Repository Pattern**: FirestoreService acts as a repository abstracting data access, allowing controller code to work with domain objects without coupling to Firestore-specific APIs. This enables easier testing (mock repository) and potential future database migration.

**Singleton Pattern**: Services (PaymentService, FirestoreService) implement singleton pattern ensuring single instances throughout app lifecycle, preventing redundant connections and maintaining consistent state.

**Observer Pattern**: BLoC controllers expose Streams that UI widgets observe for state changes, implementing reactive programming where UI automatically updates when underlying data changes.

**Composition over Inheritance**: OrderItem exists only within Order (composition relationship), never independently. When Order deletes, associated OrderItems delete automatically. This models real-world relationship—order items don't exist without parent order.

---

**Word Count**: ~780 words  
**Status**: ✅ Complete
